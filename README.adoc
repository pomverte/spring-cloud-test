# Spring Cloud Test

:toc:

Toutes les applications sont faites avec `Spring Boot` et embarque `spring-boot-actuator`

== Config Server
Mise en place d'un serveur qui centralise et externalise la configuration.
Le serveur tourne par défaut  sur le port `8888`.
Ses clés de configuration sont hébergées sur un dépôt Git https://github.com/pomverte/spring-cloud-config-repo[spring-cloud-config-repo].
On a donc une *externalisation*, une *centralisation* et un *versionning* de la configuration.

Visualiser la configuration des services par leurs noms :

- http://localhost:8888/foo-service/default
- http://localhost:8888/discovery-service/default
- http://localhost:8888/discovery-service/peer1
- http://localhost:8888/discovery-service/peer2

TIP: Il y a un mécanisme de surcharge de fichier de configuration (par défault, par service, par profil)

Rechargement de la configuration :

 curl -d{} http://localhost:8080/refresh

[NOTE]
====

- trouver comment faire pour un trigger de refresh de configuration par événement => http://cloud.spring.io/spring-cloud-bus/[spring-cloud-bus] ?
- metre de la redondance sur ce service pour éviter un SPOF
====

== Foo Service
Une application qui va charger sa configuration depuis le config server.

- http://localhost:****/message

WARNING: via la configuration par défaut le port est aléatoire `server.port = 0`

NOTE: TODO mise en place d'un fallback si le config serveur ne répond pas (config par défaut embarquée dans l'application ?)

== Discovery Service
Un `Service Registry` répliqué qui charge sa configuration depuis le config server via 2 profils Spring : `peer1` et `peer2`

Interface d'administration du Discovery Service (Eureka)

- http://localhost:8761
- http://localhost:8762

TIP: pattern `configuration-first` ou `registration-first`
